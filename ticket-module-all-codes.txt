
## File: src/modules/ticket/adapters/primary/dtos/buy-ticket.dto.ts
```
import { ApiProperty } from "@nestjs/swagger";
import { IsNotEmpty, IsString } from "class-validator";

export class BuyTicketDto {
    @ApiProperty({
        description: 'ID of the movie',
        example: 'movie-123'
    })
    @IsNotEmpty()
    @IsString()
    movieId: string;

    @ApiProperty({
        description: 'ID of the session',
        example: 'session-123'
    })
    @IsNotEmpty()
    @IsString()
    sessionId: string;
}
```


## File: src/modules/ticket/adapters/primary/dtos/watch-movie.dto.ts
```

```


## File: src/modules/ticket/adapters/primary/rest/ticket.controller.ts
```
import { Body, Controller, Get, Param, Post, UseGuards } from "@nestjs/common";
import { ApiBearerAuth, ApiOperation, ApiResponse, ApiTags } from "@nestjs/swagger";
import { CurrentUser } from "src/modules/auth/adapters/primary/rest/decorators/current-user.decorator";
import { JwtAuthGuard } from "src/modules/auth/adapters/secondary/security/jwt-adapter/jwt-auth.guard";
import { TicketService } from "src/modules/ticket/application/services/ticket.service";
import { BuyTicketDto } from "../dtos/buy-ticket.dto";
import { BuyTicketCommand } from "src/modules/ticket/application/commands/buy-ticket.command";
import { session } from "passport";
import { UseTicketCommand } from "src/modules/ticket/application/commands/use-ticket.command";

@ApiTags('tickets')
@Controller('tickets')
@UseGuards(JwtAuthGuard)
@ApiBearerAuth()
export class TicketController {
    constructor(private readonly ticketservice: TicketService){}

    @Post('buy')
    @ApiOperation({summary: 'Buy a ticket for a movie session'})
    @ApiResponse({
        status: 201,
        description: 'Ticket purchased successfully',
        schema: {
            type: 'object',
            properties: {
                id: {type: 'string'},
                movieId: {type: 'string'},
                sessionId: {type: 'string'},
                purchaseDate: {type: 'string', format: 'date-time'}
            }
        }
    })
    @ApiResponse({status: 400, description: 'Bad request'})
    @ApiResponse({ status: 401, description: 'Unauthorized' })
    @ApiResponse({ status: 404, description: 'Movie or session not found' })
    async buyTicket(@CurrentUser() user: any, @Body() buyTicketDto: BuyTicketDto) {
        const command = new BuyTicketCommand(
            user.id,
            buyTicketDto.movieId,
            buyTicketDto.sessionId
        );

        const ticket = await this.ticketservice.buyTicket(command);

        return {
            id: ticket.getId(),
            movieId: ticket.getMovieId(),
            sessionId: ticket.getSessionId(),
            purchaseDate: ticket.getPurchaseDate()
        }
    }

    @Post(':id/use')
    @ApiOperation({ summary: 'Use a ticket to watch a movie' })
    @ApiResponse({
        status: 200,
        description: 'Ticket used successfully',
        schema: {
            type: 'object',
            properties: {
                id: { type: 'string' },
                movieId: { type: 'string' },
                sessionId: { type: 'string' },
                usedDate: { type: 'string', format: 'date-time' }
            }
        }
    })
    @ApiResponse({ status: 400, description: 'Bad request' })
    @ApiResponse({ status: 401, description: 'Unauthorized' })
    @ApiResponse({ status: 404, description: 'Ticket not found' })
    @ApiResponse({ status: 409, description: 'Ticket already used' })
    async useTicket(@CurrentUser() user: any, @Param('id') ticketId: string) {
        const command = new UseTicketCommand(user.id, ticketId);
        const ticket = await this.ticketservice.useTicket(command);

        return {
            id: ticket.getId(),
            movieId: ticket.getMovieId(),
            sessionId: ticket.getSessionId(),
            usedDate: ticket.getUsedDate()
        }
    }

    @Get('unused')
    @ApiOperation({ summary: 'Get user unused tickets' })
    @ApiResponse({
        status: 200,
        description: 'Unused tickets retrieved successfully',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    movieId: { type: 'string' },
                    sessionId: { type: 'string' },
                    purchaseDate: { type: 'string', format: 'date-time' }
                }
            }
        }
    })
    @ApiResponse({ status: 404, description: 'User not found' })
    async getUserUnusedTickets(@CurrentUser() user: any) {
        return await this.getUserUnusedTickets(user.id);
    }

    @Get('history')
    @ApiOperation({ summary: 'Get user watch history' })
    @ApiResponse({
        status: 200,
        description: 'Watch history retrieved successfully',
        schema: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    id: { type: 'string' },
                    movieId: { type: 'string' },
                    sessionId: { type: 'string' },
                    purchaseDate: { type: 'string', format: 'date-time' },
                    usedDate: { type: 'string', format: 'date-time' }
                }
            }
        }
    })
    @ApiResponse({ status: 401, description: 'Unauthorized' })
    async getWatchHistory(@CurrentUser() user: any) {
        const tickets = await this.ticketservice.getUserWatchHistory(user.id);

        return tickets.map(ticket => ({
            id: ticket.getId(),
            movieId: ticket.getMovieId(),
            sessionId: ticket.getSessionId(),
            purchaseDate: ticket.getPurchaseDate(),
            usedDate: ticket.getUsedDate()
        }));
    }
}
```


## File: src/modules/ticket/adapters/secondary/persistence/ticket.mapper.ts
```
import { Injectable } from "@nestjs/common";
import { TicketTypeormEntity } from "./ticket.typeorm-entity";
import { Ticket } from "src/modules/ticket/domain/models/ticket.entity";

@Injectable()
export class TicketMapper {
    toDomain(ticketEntity: TicketTypeormEntity): Ticket | null {
        if (!ticketEntity) return null;

        return new Ticket(
            ticketEntity.id,
            ticketEntity.userId,
            ticketEntity.movieId,
            ticketEntity.sessionId,
            ticketEntity.purchaseDate,
            ticketEntity.used,
            ticketEntity.usedDate || undefined
        )
    }

    toPersistance(ticket: Ticket): TicketTypeormEntity {
        const ticketEntity = new TicketTypeormEntity();
        ticketEntity.id = ticket.getId(),
        ticketEntity.userId = ticket.getUserId();
        ticketEntity.movieId = ticket.getMovieId();
        ticketEntity.sessionId = ticket.getSessionId();
        ticketEntity.purchaseDate = ticket.getPurchaseDate();
        ticketEntity.used = ticket.isUsed();
        ticketEntity.usedDate = ticket.getUsedDate() || null;
        
        return ticketEntity;
    }
}
```


## File: src/modules/ticket/adapters/secondary/persistence/ticket.typeorm-entity.ts
```
import { Column, CreateDateColumn, Entity, PrimaryColumn } from "typeorm";

@Entity('tickets')
export class TicketTypeormEntity {
    @PrimaryColumn('uuid')
    id: string;

    @Column('uuid')
    userId: string;

    @Column('uuid')
    movieId: string;

    @Column('uuid')
    sessionId: string;

    @CreateDateColumn()
    purchaseDate: Date;

    @Column('boolean', {default: false})
    used: boolean;

    @Column('timestamp', {nullable: true})
    usedDate: Date | null;
}
```


## File: src/modules/ticket/adapters/secondary/persistence/typeorm-ticket.repositoty.ts
```
import { Injectable } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { ITicketRepository } from "src/modules/ticket/application/ports/ticket-repository.interface";
import { TicketTypeormEntity } from "./ticket.typeorm-entity";
import { Repository } from "typeorm";
import { TicketMapper } from "./ticket.mapper";
import { Ticket } from "src/modules/ticket/domain/models/ticket.entity";

@Injectable()
export class TypeormTicketRepository implements ITicketRepository {
    constructor(
        @InjectRepository(TicketTypeormEntity)
        private readonly ticketRepository: Repository<TicketTypeormEntity>,
        private readonly ticketMapper: TicketMapper
    ) {}

    async save(ticket: Ticket): Promise<Ticket> {
        const ticketEntity = this.ticketMapper.toPersistance(ticket);
        const savedEntity = await this.ticketRepository.save(ticketEntity);
        const domainTicket = this.ticketMapper.toDomain(savedEntity);

        if (!domainTicket) {
            throw new Error('Failed to map saved Entity back to domain model');
        }

        return domainTicket;
    }

    async findById(id: string): Promise<Ticket | null> {
        const ticketEntity = await this.ticketRepository.findOne({where: {id}});

        return ticketEntity ? this.ticketMapper.toDomain(ticketEntity) : null;
    }

    async findByUserAndSession(userId: string, movieId: string): Promise<Ticket | null> {
        const ticketEntity = await this.ticketRepository.findOne({
            where: {
                userId,
                movieId
            }
        });

        return ticketEntity ? this.ticketMapper.toDomain(ticketEntity) : null;
    }

    async findBySession(sessionId: string): Promise<Ticket[]> {
        const ticketEntities = await this.ticketRepository.find({
            where: {
                sessionId
            },
            order: {
                purchaseDate: 'ASC'
            }
        });

        return this.mapEntitiesToDomain(ticketEntities);
    }

    async findByUser(userId: string): Promise<Ticket[]> {
        const ticketEntities = await this.ticketRepository.find({
            where: {userId},
            order: {
                purchaseDate: 'DESC'
            }
        });

        return this.mapEntitiesToDomain(ticketEntities);
    }

    async findUsedTicketsByUser(userId: string): Promise<Ticket[]> {
        const ticketEntities = await this.ticketRepository.find({
            where: {
                userId,
                used: true
            },
            order: {
                purchaseDate: 'DESC'
            }
        });

        return this.mapEntitiesToDomain(ticketEntities);
    }

    async findUnusedTicketsByUser(userId: string): Promise<Ticket[]> {
        const ticketEntities = await this.ticketRepository.find({
            where: { 
                userId,
                used: false 
            },
            order: {
                purchaseDate: 'DESC'
            }
        });

        return this.mapEntitiesToDomain(ticketEntities);
    }

    private mapEntitiesToDomain(entities: TicketTypeormEntity[]): Ticket[] {
        return entities
            .map(entity => this.ticketMapper.toDomain(entity))
            .filter(ticket => ticket !== null) as Ticket[]
    }

    async delete(ticketId: string): Promise<void> {
        await this.ticketRepository.delete(ticketId);
    }
}
```


## File: src/modules/ticket/application/commands/buy-ticket.command.ts
```
export class BuyTicketCommand {
    constructor(
        public readonly userId: string,
        public readonly movieId: string,
        public readonly sessionId: string
    ) {}
}
```


## File: src/modules/ticket/application/commands/use-ticket.command.ts
```
export class UseTicketCommand {
    constructor(
        public readonly userId: string,
        public readonly ticketId: string
    ) {}
}
```


## File: src/modules/ticket/application/event-handlers/ticket-created.handler.ts
```
import { EventsHandler, IEventHandler } from "@nestjs/cqrs";
import { TicketCreatedEvent } from "../../domain/events/ticket-created.event";
import { Logger } from "@nestjs/common";

@EventsHandler(TicketCreatedEvent)
export class TicketCreatedHandler implements IEventHandler<TicketCreatedEvent> {
    private readonly logger = new Logger(TicketCreatedHandler.name);

    handle(event: TicketCreatedEvent) {
        this.logger.log(
            `Ticket created - ID: ${event.ticketId}, User: ${event.userId}, Movie: ${event.movieId}, Session: ${event.sessionId}`
        );

        // additional handling could be added
        // - send confirmation email
        // - notify staff
        // - etc
    }
}
```


## File: src/modules/ticket/application/event-handlers/ticket-used.handler.ts
```
import { EventsHandler, IEventHandler } from "@nestjs/cqrs";
import { TicketUsedEvent } from "../../domain/events/ticket-used-event";
import { Logger } from "@nestjs/common";

@EventsHandler(TicketUsedEvent)
export class TicketUsedHandler implements IEventHandler<TicketUsedEvent> {
    private readonly logger = new Logger(TicketUsedHandler.name);

    handle(event: TicketUsedEvent) {
        this.logger.log(
            `Ticket used - ID: ${event.ticketId}, User: ${event.userId}, Movie: ${event.movieId}`
        );

        // additional handling could be:
        // - generating viewing statistics
        // - triggering loyalty program points
        // - etc
    }
}
```


## File: src/modules/ticket/application/ports/ticket-repository.interface.ts
```
import { Ticket } from "../../domain/models/ticket.entity";

export abstract class ITicketRepository {
    abstract save(ticket: Ticket): Promise<Ticket>;
    abstract findById(id: string): Promise<Ticket | null>;
    abstract findByUserAndSession(userId: string, sessionId: string): Promise<Ticket | null>
    abstract findBySession(sessionId: string): Promise<Ticket[]>;
    abstract findByUser(userId: string): Promise<Ticket[]>;
    abstract findUsedTicketsByUser(userId: string): Promise<Ticket[]>
    abstract findUnusedTicketsByUser(userId: string): Promise<Ticket[]>
    abstract delete(ticketId: string): Promise<void>;
}
```


## File: src/modules/ticket/application/services/ticket.service.ts
```
import { BadRequestException, ConflictException, Injectable, NotFoundException } from "@nestjs/common";
import { ITicketRepository } from "../ports/ticket-repository.interface";
import { MovieService } from "src/modules/movie/application/services/movie.service";
import { Userservice } from "src/modules/auth/application/services/user.service";
import { Ticket } from "../../domain/models/ticket.entity";
import {v4 as uuidv4} from "uuid";
import { BuyTicketCommand } from "../commands/buy-ticket.command";
import { UseTicketCommand } from "../commands/use-ticket.command";

@Injectable()
export class TicketService {
    constructor(
        private readonly ticketRepository: ITicketRepository,
        private readonly movieService: MovieService,
        private readonly userService: Userservice
    ) {}

    /**
     * Buys a ticket for a user for a given session.
     * 
     * This method first verifies that the user exists and has a valid age for the movie.
     * It then uses the MovieService to book a seat for the user in the session.
     * If the user already has a ticket for this session, a ConflictException is thrown.
     * 
     * @param command BuyTicketCommand object containing the user id, movie id and session id.
     * @returns A Ticket object representing the newly created ticket.
     * @throws NotFoundException if the user does not exist.
     * @throws BadRequestException if the user is not old enough for the movie.
     * @throws ConflictException if the user already has a ticket for this session.
     */
    async buyTicket(command: BuyTicketCommand): Promise<Ticket> {
        const {userId, movieId, sessionId} = command;

        // Verify user exists and get details
        const user = await this.userService.getUserById(userId);

        // Check if user has already a ticket for this session
        const existingTickets = await this.ticketRepository.findByUserAndSession(userId, sessionId);
        if (existingTickets) {
            throw new ConflictException('User already has a ticket for this session');
        }

        // Let MovieService handle all movie/session related validations
        await this.movieService.bookSessionSeats(movieId, sessionId, 1, user.getAge());

        // Create new ticket
        const ticket = new Ticket(
            uuidv4(),
            userId,
            movieId,
            sessionId
        );

        return this.ticketRepository.save(ticket);
    }

    /**
     * Uses a ticket for a user.
     * 
     * This method first verifies that the user owns the ticket and that the ticket has not been used before.
     * It then verifies that the movie and session still exist.
     * If the verifications pass, the ticket is marked as used and saved back to ticket repository
     * 
     * @param command UseTicketCommand object containing the user id and ticket id.
     * @returns The updated Ticket object.
     * @throws NotFoundException if the ticket does not exist.
     * @throws BadRequestException if the ticket belongs to another user or the movie session no longer exists.
     * @throws ConflictException if the ticket has already been used.
     */
    async useTicket(command: UseTicketCommand): Promise<Ticket> {
        const {userId, ticketId} = command;

        // Find the ticket
        const ticket = await this.ticketRepository.findById(ticketId);
        if (!ticket) {
            throw new NotFoundException(`Ticket ${ticketId} not found`);
        }

        // Verify ticket ownership
        if (ticket.getUserId() !== userId) {
            throw new BadRequestException('Ticket belongs to another user');
        }

        // Ckeck if ticket has already been used
        if (ticket.isUsed()) {
            throw new ConflictException('Ticket has already been used');
        }

        // Verify the movie and session still eexists
        const movie = await this.movieService.getMovieById(ticket.getMovieId());
        const session = movie.getSession(ticket.getSessionId());
        if (!session) {
            throw new BadRequestException('Movie session no longer exists');
        }

        // Mark ticket as used
        ticket.useTicket();
        return await this.ticketRepository.save(ticket);
    }

   
    /**
     * Retrieves all tickets associated with a specific user.
     * 
     * This method first verifies that the user exists.
     * If the user is found, it returns a list of tickets belonging to the user.
     * 
     * @param userId The ID of the user whose tickets are being retrieved.
     * @returns A promise that resolves to an array of Ticket objects for the user.
     * @throws NotFoundException if the user does not exist.
     */
    async getUserTickets(userId: string): Promise<Ticket[]> {
        // Verify user exists
        await this.userService.getUserById(userId);
        return await this.ticketRepository.findByUser(userId);
    }

    /**
     * Retrieves all unused tickets associated with a specific user.
     * 
     * This method first verifies that the user exists.
     * If the user is found, it returns a list of tickets belonging to the user that have not been used.
     * 
     * @param userId The ID of the user whose tickets are being retrieved.
     * @returns A promise that resolves to an array of Ticket objects for the user that have not been used.
     * @throws NotFoundException if the user does not exist.
     */
    async getUserUnusedTickets(userId: string): Promise<Ticket[]> {
        // Verify user exists
        await this.userService.getUserById(userId);
        return await this.ticketRepository.findUnusedTicketsByUser(userId);
    }

    /**
     * Retrieves all tickets associated with a specific user that have been used(Watch history).
     * 
     * This method first verifies that the user exists.
     * If the user is found, it returns a list of tickets belonging to the user which have been used.
     * 
     * @param userId The ID of the user whose tickets are being retrieved.
     * @returns A promise that resolves to an array of Ticket objects that have been used by the user.
     * @throws NotFoundException if the user does not exist.
     */
    async getUserWatchHistory(userId: string): Promise<Ticket[]> {
        // verify user exists
        await this.userService.getUserById(userId);
        const tickets = await this.ticketRepository.findUsedTicketsByUser(userId);
        return tickets;
    }

    /**
     * Retrieves a ticket by its ID.
     * 
     * This method simply retrieves a ticket by its ID.
     * 
     * @param ticketId The ID of the ticket being retrieved.
     * @returns A promise that resolves to the Ticket object or rejects with a NotFoundException if the ticket does not exist.
     */
    async getTicketById(ticketId: string): Promise<Ticket> {
        const ticket = await this.ticketRepository.findById(ticketId);
        if (!ticket) {
            throw new NotFoundException(`Ticket ${ticketId} not found`);
        }
        return ticket;
    }

    /**
     * This method queries the ticket repository for all tickets related to the given session ID
     * and returns the count of those tickets.
     * 
     * @param sessionId The ID of the session whose ticket count is being retrieved.
     * @returns A promise that resolves to the number of tickets for the session.
     */

    async getSessionTicketCount(sessionId: string): Promise<number> {
        const tickets = await this.ticketRepository.findBySession(sessionId);
        return tickets.length;
    }
}
```


## File: src/modules/ticket/domain/events/ticket-created.event.ts
```
export class TicketCreatedEvent {
    constructor(
        public readonly ticketId: string,
        public readonly userId: string,
        public readonly movieId: string,
        public readonly sessionId: string
    ) {}
}
```


## File: src/modules/ticket/domain/events/ticket-used-event.ts
```
export class TicketUsedEvent {
    constructor(
        public readonly ticketId: string,
        public readonly userId: string,
        public readonly movieId: string
    ) {}
}
```


## File: src/modules/ticket/domain/models/ticket.entity.ts
```
import { AggregateRoot, IEvent } from "@nestjs/cqrs";
import { TicketCreatedEvent } from "../events/ticket-created.event";
import { TicketUsedEvent } from "../events/ticket-used-event";


export class Ticket extends AggregateRoot {
    private readonly _id: string;
    private readonly _userId: string;
    private readonly _movieId: string;
    private readonly _sessionId: string;
    private readonly _purchaseDate: Date;
    private _used: boolean;
    private _usedDate?: Date;

    constructor(
        id: string,
        userId: string,
        movieId: string,
        sessionId: string,
        purchaseDate = new Date(),
        used = false,
        usedDate?: Date
    ) {
        super();
        this._id = id;
        this._userId = userId;
        this._movieId = movieId;
        this._sessionId = sessionId;
        this._purchaseDate = purchaseDate;
        this._used = used;
        this._usedDate = usedDate;

        this.apply(new TicketCreatedEvent(id, userId, movieId, sessionId));
    }

    // Getters
    public getId(): string {
        return this._id;
    }

    public getUserId(): string {
        return this._userId;
    }

    public getMovieId(): string {
        return this._movieId;
    }

    public getSessionId(): string {
        return this._sessionId;
    }

    public getPurchaseDate(): Date {
        return this._purchaseDate;
    }

    public isUsed(): boolean {
        return this._used;
    }

    public getUsedDate(): Date | undefined {
        return this._usedDate;
    }

    // Domain methods
    public useTicket(): void {
        if (this._used) {
            throw new Error('Ticket has already been used');
        }

        this._used = true;
        this._usedDate = new Date();
        this.apply(new TicketUsedEvent(this._id, this._userId, this._movieId));
    }

    // Factory method
    public static create(
        id: string,
        userId: string,
        movieId: string,
        sessionId: string
    ): Ticket {
        return new Ticket(id, userId, movieId, sessionId);
    }
}
```


## File: src/modules/ticket/test/integration/ticket.integration.spec.ts
```

```


## File: src/modules/ticket/test/unit/application/ticket.service.spec.ts
```
import { BadRequestException, ConflictException, NotFoundException } from "@nestjs/common";
import { Test, TestingModule } from "@nestjs/testing";
import { Userservice } from "src/modules/auth/application/services/user.service";
import { User } from "src/modules/auth/domain/models/user.entity";
import { MovieService } from "src/modules/movie/application/services/movie.service";
import { Movie } from "src/modules/movie/domain/models/movie.entity";
import { BuyTicketCommand } from "src/modules/ticket/application/commands/buy-ticket.command";
import { UseTicketCommand } from "src/modules/ticket/application/commands/use-ticket.command";
import { ITicketRepository } from "src/modules/ticket/application/ports/ticket-repository.interface";
import { TicketService } from "src/modules/ticket/application/services/ticket.service"
import { Ticket } from "src/modules/ticket/domain/models/ticket.entity";

describe('TicketService', () => {
    let service: TicketService;
    let ticketRepository: jest.Mocked<ITicketRepository>;
    let movieService: jest.Mocked<MovieService>;
    let userService: jest.Mocked<Userservice>;

    const mockUserId = '123e4567-e89b-12d3-a456-426614174000';
    const mockMovieId = '123e4567-e89b-12d3-a456-426614174001';
    const mockSessionId = '123e4567-e89b-12d3-a456-426614174002';
    const mockTicketId = '123e4567-e89b-12d3-a456-426614174003';

    beforeEach(async () => {
        const ticketRepositoryMock = {
            save: jest.fn(),
            findById: jest.fn(),
            findByUser: jest.fn(),
            findByUserAndSession: jest.fn(),
            findBySession: jest.fn(),
            findUsedTicketsByUser: jest.fn(),
            findUnusedTicketsByUser: jest.fn(),
            delete: jest.fn()
        }

        const movieServiceMock = {
            bookSessionSeats: jest.fn(),
            getMovieById: jest.fn()
        }

        const userServiceMock = {
            getUserById: jest.fn()
        }

        const module: TestingModule = await Test.createTestingModule({
            providers: [
                TicketService,
                {
                    provide: ITicketRepository,
                    useValue: ticketRepositoryMock
                },
                {
                    provide: MovieService,
                    useValue: movieServiceMock
                },
                {
                    provide: Userservice,
                    useValue: userServiceMock
                }
            ]
        }).compile();

        service = module.get(TicketService);
        ticketRepository = module.get(ITicketRepository);
        movieService = module.get(MovieService);
        userService = module.get(Userservice);
    });

    describe('buyTicket', () => {
        const mockUser = {
            getAge: () => 25,
        } as User;

        const buyTicketCommand = new BuyTicketCommand(
            mockUserId,
            mockMovieId,
            mockSessionId
        );

        it('should successfully buy a ticket', async () => {
            userService.getUserById.mockResolvedValue(mockUser);
            ticketRepository.findByUserAndSession.mockResolvedValue(null);
            movieService.bookSessionSeats.mockResolvedValue(undefined);
            // we need it to return back whatever ticket we passed to save, so we mock implementation
            ticketRepository.save.mockImplementation((ticket) => Promise.resolve(ticket));

            const result = await service.buyTicket(buyTicketCommand);

            expect(result).toBeDefined();
            expect(result.getUserId()).toBe(mockUserId);
            expect(result.getMovieId()).toBe(mockMovieId);
            expect(result.getSessionId()).toBe(mockSessionId);
            expect(result.isUsed()).toBe(false);
        });

        it('should throw ConflictException when a user already has a ticket', async () => {
            userService.getUserById.mockResolvedValue(mockUser);
            ticketRepository.findByUserAndSession.mockResolvedValue(new Ticket(mockTicketId, mockUserId, mockMovieId, mockSessionId));
            movieService.bookSessionSeats.mockResolvedValue(undefined);

            await expect(service.buyTicket(buyTicketCommand))
                .rejects
                .toThrow(ConflictException);
        });
    });

    describe('useticket', () => {
        const useTicketCommand = new UseTicketCommand(mockUserId, mockTicketId);

        const mockTicket = new Ticket(
            mockTicketId,
            mockUserId,
            mockMovieId,
            mockSessionId
        );

        const mockMovie = {
            getSession: jest.fn().mockReturnValue({ id: mockSessionId })
        } as unknown as Movie;

        it('should successfully use a ticket', async () => {
            // Arrange
            ticketRepository.findById.mockResolvedValue(mockTicket);
            movieService.getMovieById.mockResolvedValue(mockMovie);
            ticketRepository.save.mockImplementation(ticket => Promise.resolve(ticket));
            expect(mockTicket.isUsed()).toBe(false);

            // Act
            const result = await service.useTicket(useTicketCommand);

            // Assert
            expect(result).toBeDefined();
            expect(result.getUsedDate()).toBeDefined();
            expect(result.isUsed()).toBe(true);
        });

        it('should throw NotFoundException when ticket not found', async () => {
            ticketRepository.findById.mockResolvedValue(null);

            await expect(service.useTicket(useTicketCommand))
                .rejects
                .toThrow(NotFoundException);
        });

        it('should throw BadRequestException when ticket belongs to another user', async () => {
            const wrongTicket = new Ticket(
                mockTicketId,
                'wrong-user-id',
                mockMovieId,
                mockSessionId
            );
            ticketRepository.findById.mockResolvedValue(wrongTicket);

            await expect(service.useTicket(useTicketCommand))
                .rejects
                .toThrow(BadRequestException);
        });

        it('should throw ConflictException when ticket already used', async () => {
            const usedTicket = new Ticket(
                mockTicketId,
                mockUserId,
                mockMovieId,
                mockSessionId
            );
            usedTicket.useTicket();
            ticketRepository.findById.mockResolvedValue(usedTicket);

            await expect(service.useTicket(useTicketCommand))
                .rejects
                .toThrow(ConflictException);
        });
    });

    describe('getUserTickets', () => {
        it('should return user tickets', async () => {
            const mockTickets = [
                new Ticket(mockTicketId, mockUserId, mockMovieId, mockSessionId)
            ];
            userService.getUserById.mockResolvedValue({} as User);
            ticketRepository.findByUser.mockResolvedValue(mockTickets);

            const result = await service.getUserTickets(mockUserId);

            expect(result).toEqual(mockTickets);
            expect(ticketRepository.findByUser).toHaveBeenCalledWith(mockUserId);
        });

        it('should throw NotFoundException when user not found', async () => {
            userService.getUserById.mockRejectedValue(new NotFoundException());

            await expect(service.getUserTickets(mockUserId))
                .rejects
                .toThrow(NotFoundException);
        });
    });

    describe('getTicketById', () => {
        it('should return ticket when found', async () => {
            const mockTicket = new Ticket(
                mockTicketId,
                mockUserId,
                mockMovieId,
                mockSessionId
            );
            ticketRepository.findById.mockResolvedValue(mockTicket);

            const result = await service.getTicketById(mockTicketId);

            expect(result).toEqual(mockTicket);
        });

        it('should throw NotFoundException when ticket not found', async () => {
            ticketRepository.findById.mockResolvedValue(null);

            await expect(service.getTicketById(mockTicketId))
                .rejects
                .toThrow(NotFoundException);
        });
    });

    describe('getSessionTicketCount', () => {
        it('should return correct ticket count', async () => {
            const mockTickets = [
                new Ticket(mockTicketId, mockUserId, mockMovieId, mockSessionId),
                new Ticket('ticket-123', 'user-123', 'movie-123', 'session-123')
            ];
            ticketRepository.findBySession.mockResolvedValue(mockTickets);

            const result = await service.getSessionTicketCount(mockSessionId);

            expect(result).toBe(2);
            expect(ticketRepository.findBySession).toHaveBeenCalledWith(mockSessionId);
        });
    });
})
```


## File: src/modules/ticket/test/unit/domain/ticket.entity.spec.ts
```
import { TicketUsedEvent } from "src/modules/ticket/domain/events/ticket-used-event";
import { Ticket } from "src/modules/ticket/domain/models/ticket.entity";
import {v4 as uuidv4} from "uuid";

describe('Ticket Entity', () => {
    let ticket: Ticket;
    const ticketId = uuidv4();
    const userId = uuidv4();
    const movieId = uuidv4();
    const sessionId = uuidv4();

    beforeEach(() => {
        ticket = Ticket.create(ticketId, userId, movieId, sessionId);
    });

    describe('create', () => {
        it('should create a ticket with correct properties', () => {
            expect(ticket.getId()).toBe(ticketId);
            expect(ticket.getUserId()).toBe(userId);
            expect(ticket.getMovieId()).toBe(movieId);
            expect(ticket.getSessionId()).toBe(sessionId);
            expect(ticket.isUsed()).toBe(false);
            expect(ticket.getUsedDate()).toBeUndefined();
        });

        it('should apply TicketCreatedEvent', () => {
            const events = ticket.getUncommittedEvents();
            const event = events[0];
            expect(event.constructor.name).toBe('TicketCreatedEvent');
        })
    });

    describe('useTicket', () => {
        it('should mark ticket as used', () => {
            ticket.useTicket();

            expect(ticket.isUsed()).toBe(true);
            expect(ticket.getUsedDate()).toBeDefined();
        });

        it('should throw error when using already used ticket', () => {
            ticket.useTicket();

            expect(() => ticket.useTicket()).toThrow('Ticket has already been used');
        });

        it('should apply TicketUsedEvent', () => {
            ticket.useTicket();
            const events = ticket.getUncommittedEvents();
            const event = events[1];
            expect(event.constructor.name).toBe('TicketUsedEvent')
        })
    })
})
```


## File: src/modules/ticket/test/unit/infrastructure/ticket.mapper.spec.ts
```
import { TicketMapper } from "src/modules/ticket/adapters/secondary/persistence/ticket.mapper";
import { Ticket } from "src/modules/ticket/domain/models/ticket.entity";
import { TicketTypeormEntity } from "src/modules/ticket/adapters/secondary/persistence/ticket.typeorm-entity";

describe('TicketMapper', () => {
    let mapper: TicketMapper;
    const mockId = '123e4567-e89b-12d3-a456-426614174000';
    const mockUserId = '123e4567-e89b-12d3-a456-426614174001';
    const mockMovieId = '123e4567-e89b-12d3-a456-426614174002';
    const mockSessionId = '123e4567-e89b-12d3-a456-426614174003';
    const mockPurchaseDate = new Date('2024-02-23');

    beforeEach(() => {
        mapper = new TicketMapper();
    });

    describe('toDomain', () => {
        it('should return null when entity is null', () => {
            expect(mapper.toDomain(null as unknown as TicketTypeormEntity)).toBe(null);
        });

        it('should map unused ticket entity to domain model', () => {
            const ticketEntity = new TicketTypeormEntity();
            ticketEntity.id = mockId;
            ticketEntity.userId = mockUserId;
            ticketEntity.movieId = mockMovieId;
            ticketEntity.sessionId = mockSessionId;
            ticketEntity.purchaseDate = mockPurchaseDate;
            ticketEntity.used = false;
            ticketEntity.usedDate = null;

            const ticket = mapper.toDomain(ticketEntity);

            expect(ticket).toBeDefined();
            expect(ticket?.getId()).toBe(mockId);
            expect(ticket?.getUserId()).toBe(mockUserId);
            expect(ticket?.getMovieId()).toBe(mockMovieId);
            expect(ticket?.getSessionId()).toBe(mockSessionId);
            expect(ticket?.getPurchaseDate()).toEqual(mockPurchaseDate);
            expect(ticket?.isUsed()).toBe(false);
            expect(ticket?.getUsedDate()).toBeUndefined();
        });

        it('should map used ticket entity to domain model', () => {
            const usedDate = new Date('2024-02-23');
            const ticketEntity = new TicketTypeormEntity();
            ticketEntity.id = mockId;
            ticketEntity.userId = mockUserId;
            ticketEntity.movieId = mockMovieId;
            ticketEntity.sessionId = mockSessionId;
            ticketEntity.purchaseDate = mockPurchaseDate;
            ticketEntity.used = true;
            ticketEntity.usedDate = usedDate;

            const ticket = mapper.toDomain(ticketEntity);

            expect(ticket).toBeDefined();
            expect(ticket?.getId()).toBe(mockId);
            expect(ticket?.getUserId()).toBe(mockUserId);
            expect(ticket?.getMovieId()).toBe(mockMovieId);
            expect(ticket?.getSessionId()).toBe(mockSessionId);
            expect(ticket?.getPurchaseDate()).toEqual(mockPurchaseDate);
            expect(ticket?.isUsed()).toBe(true);
            expect(ticket?.getUsedDate()).toEqual(usedDate);
        });
    });

    describe('toPersistance', () => {
        it('should map unused ticket domain model to entity', () => {
            const ticket = new Ticket(
                mockId,
                mockUserId,
                mockMovieId,
                mockSessionId,
                mockPurchaseDate,
                false
            );

            const entity = mapper.toPersistance(ticket);

            expect(entity).toBeDefined();
            expect(entity.id).toBe(mockId);
            expect(entity.userId).toBe(mockUserId);
            expect(entity.movieId).toBe(mockMovieId);
            expect(entity.sessionId).toBe(mockSessionId);
            expect(entity.purchaseDate).toEqual(mockPurchaseDate);
            expect(entity.used).toBe(false);
            expect(entity.usedDate).toBeNull();
        });

        it('should map used ticket domain model to entity', () => {
            const usedDate = new Date('2024-02-24');
            const ticket = new Ticket(
                mockId,
                mockUserId,
                mockMovieId,
                mockSessionId,
                mockPurchaseDate,
                true,
                usedDate
            );

            const entity = mapper.toPersistance(ticket);

            expect(entity).toBeDefined();
            expect(entity.id).toBe(mockId);
            expect(entity.userId).toBe(mockUserId);
            expect(entity.movieId).toBe(mockMovieId);
            expect(entity.sessionId).toBe(mockSessionId);
            expect(entity.purchaseDate).toEqual(mockPurchaseDate);
            expect(entity.used).toBe(true);
            expect(entity.usedDate).toEqual(usedDate);
        });
    });
})
```


## File: src/modules/ticket/ticket.module.ts
```
import { Module } from "@nestjs/common";
import { TicketCreatedHandler } from "./application/event-handlers/ticket-created.handler";
import { TicketUsedHandler } from "./application/event-handlers/ticket-used.handler";
import { CqrsModule } from "@nestjs/cqrs";
import { TypeOrmModule } from "@nestjs/typeorm";
import { TicketTypeormEntity } from "./adapters/secondary/persistence/ticket.typeorm-entity";
import { MovieModule } from "../movie/movie.module";
import { AuthModule } from "../auth/auth.module";
import { TicketController } from "./adapters/primary/rest/ticket.controller";
import { TicketService } from "./application/services/ticket.service";
import { ITicketRepository } from "./application/ports/ticket-repository.interface";
import { TypeormTicketRepository } from "./adapters/secondary/persistence/typeorm-ticket.repositoty";
import { TicketMapper } from "./adapters/secondary/persistence/ticket.mapper";

const eventHandlers = [TicketCreatedHandler, TicketUsedHandler];

@Module({
    imports: [
        CqrsModule,
        TypeOrmModule.forFeature([TicketTypeormEntity]),
        MovieModule,
        AuthModule
    ],
    controllers: [TicketController],
    providers: [
        // Application layer
        TicketService,

        // Domain layer - Ports implementations (port:adapter)
        {
            provide: ITicketRepository,
            useClass: TypeormTicketRepository
        },

        // Secondary adapters - Mappers
        TicketMapper,

        // Event handlers
        ...eventHandlers
    ],
    exports: [TicketService]
})
export class TicketModule {}
```
